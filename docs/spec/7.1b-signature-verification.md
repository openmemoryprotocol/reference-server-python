7.1b — Signature Verification

This stage defines how the server verifies cryptographic signatures on incoming requests.
It builds on 7.1a (syntax validation), and introduces semantic checks.

Request Handling

When a request arrives with Signature-Input and Signature headers:

Parse Headers

Run parse_signature_input() and parse_signature().

If parsing fails (bad syntax, malformed structure) → return 400 Bad Request.

Find Signature Label

The same label (e.g. sig1) must exist in both headers.

If missing or mismatched → 400 Bad Request.

Extract Key ID

From Signature-Input.

If missing → 400 Bad Request.

If keyid provided but not recognized by server → 401 Unauthorized.

Build Signing Base

Use request method, path, and headers as defined in HTTP Signatures spec.

Decode Signature

Base64url decode the signature.

If decoding fails → 401 Unauthorized.

Verify Signature

Use Ed25519 public key associated with keyid.

If verification fails → 401 Unauthorized.

Response Semantics

400 Bad Request → client sent structurally invalid data.

401 Unauthorized → client identified but failed authentication.

This split is essential:

400 = you didn’t even speak the protocol correctly.

401 = you spoke correctly, but you don’t have valid keys.

Test Coverage

✅ test_strict_mode_passes_on_wellformed_syntax

✅ test_bad_signature_401

✅ Unknown keyid returns 401

✅ Malformed headers return 400

All tests pass, closing the loop on 7.1b.

✨ Status: COMPLETE
(Commit/tag: 7.1b-finalized)
